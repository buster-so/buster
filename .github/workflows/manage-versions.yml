name: Manage Versions

on:
  pull_request:
    types: [closed]
    branches:
      - staging
  workflow_dispatch:
    inputs:
      component:
        description: 'Component to version bump (if running manually)'
        required: true
        default: 'all'
        type: choice
        options: [all, api, web, cli]
      version_spec:
        description: 'Version bump type or specific version (if running manually)'
        required: true
        default: 'patch'
        type: string
      pr_branch:
        description: 'Name of the PR source branch (required if dispatching for a PR)'
        required: false
        type: string

permissions:
  contents: write # To push commits back to the PR branch

jobs:
  # Job to merge staging into evals branch when PR is merged
  merge_to_evals:
    name: Merge Staging to Evals
    if: github.event.pull_request.merged == true
    runs-on: blacksmith
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge staging into evals
        run: |
          git checkout evals
          git merge staging --no-ff -m "chore: merge staging into evals [skip ci]"
          git push origin evals

  # Job to determine version bump parameters
  determine_version_params:
    name: Determine Version Parameters
    runs-on: blacksmith
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    outputs:
      version_spec: ${{ steps.event_params.outputs.version_spec }}
      component: ${{ steps.event_params.outputs.component }}
      target_branch: ${{ steps.pr_branch_info.outputs.target_branch_name }}
    steps:
      - name: Determine Target Branch
        id: pr_branch_info
        shell: bash
        run: |
          TARGET_BRANCH=""
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            TARGET_BRANCH="${{ github.head_ref }}"
            echo "Detected PR event. Will operate on PR source branch: $TARGET_BRANCH"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ -z "${{ github.event.inputs.pr_branch }}" ]]; then
              echo "Error: 'pr_branch' input is required for manual dispatch to update a PR."
              exit 1
            fi
            TARGET_BRANCH="${{ github.event.inputs.pr_branch }}"
            echo "Detected workflow_dispatch event. Will operate on specified PR branch: $TARGET_BRANCH"
          else
            echo "Error: Unhandled event type '${{ github.event_name }}'"
            exit 1
          fi
          echo "target_branch_name=$TARGET_BRANCH" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Changed Components
        id: changed_components
        if: github.event_name == 'pull_request'
        run: |
          # Get the base and head commits for the PR
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only $BASE_SHA $HEAD_SHA)
          
          # Initialize component flags
          HAS_API_CHANGES="false"
          HAS_WEB_CHANGES="false"
          HAS_CLI_CHANGES="false"
          
          # Check for changes in each component
          if echo "$CHANGED_FILES" | grep -q "^api/"; then
            HAS_API_CHANGES="true"
            echo "API changes detected"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^web/"; then
            HAS_WEB_CHANGES="true"
            echo "Web changes detected"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^cli/"; then
            HAS_CLI_CHANGES="true"
            echo "CLI changes detected"
          fi
          
          # Set outputs
          echo "has_api_changes=$HAS_API_CHANGES" >> $GITHUB_OUTPUT
          echo "has_web_changes=$HAS_WEB_CHANGES" >> $GITHUB_OUTPUT
          echo "has_cli_changes=$HAS_CLI_CHANGES" >> $GITHUB_OUTPUT

      - name: Determine Version Spec and Component
        id: event_params
        shell: bash
        run: |
          VERSION_SPEC=""
          COMPONENT=""

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION_SPEC="${{ github.event.inputs.version_spec }}"
            COMPONENT="${{ github.event.inputs.component }}"
            echo "Using workflow_dispatch inputs: version_spec='$VERSION_SPEC', component='$COMPONENT'"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_TITLE=$(echo "${{ github.event.pull_request.title }}" | tr '[:upper:]' '[:lower:]')
            
            # Determine which components have changes
            if [[ "${{ steps.changed_components.outputs.has_api_changes }}" == "true" ]]; then
              COMPONENT="api"
            elif [[ "${{ steps.changed_components.outputs.has_web_changes }}" == "true" ]]; then
              COMPONENT="web"
            elif [[ "${{ steps.changed_components.outputs.has_cli_changes }}" == "true" ]]; then
              COMPONENT="cli"
            else
              echo "No changes detected in API, Web, or CLI components. Skipping version bump."
              COMPONENT="none"
            fi

            # Determine version spec based on PR title
            if echo "$PR_TITLE" | grep -q -E "breaking change|feat!:"; then VERSION_SPEC="major";
            elif echo "$PR_TITLE" | grep -q -E "^feat\\([^)]+\\)!:"; then VERSION_SPEC="major";
            elif echo "$PR_TITLE" | grep -q -E "^feat:"; then VERSION_SPEC="minor";
            elif echo "$PR_TITLE" | grep -q -E "^fix:"; then VERSION_SPEC="patch";
            else
              echo "No conventional commit keyword (major/minor/patch) found in PR title '$PR_TITLE'."
              echo "Version bumping will not occur automatically for this push to the PR."
              VERSION_SPEC="patch"
            fi
            echo "Determined for PR to staging: version_spec='$VERSION_SPEC', component='$COMPONENT'"
          fi
          
          if [[ -z "$VERSION_SPEC" ]]; then
            echo "Warning: VERSION_SPEC is empty. Defaulting to patch."
            VERSION_SPEC="patch"
          fi
          if [[ -z "$COMPONENT" ]]; then
            echo "Warning: COMPONENT is empty. Defaulting to none."
            COMPONENT="none"
          fi

          echo "version_spec=$VERSION_SPEC" >> $GITHUB_OUTPUT
          echo "component=$COMPONENT" >> $GITHUB_OUTPUT

  # Job to bump API version
  bump_api_version:
    name: Bump API Version
    needs: determine_version_params
    if: |
      (needs.determine_version_params.outputs.component == 'all' || 
       needs.determine_version_params.outputs.component == 'api') &&
      needs.determine_version_params.outputs.component != 'none'
    runs-on: blacksmith
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
      old_version: ${{ steps.bump.outputs.old_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine_version_params.outputs.target_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Install cargo-edit
        run: cargo install cargo-edit --locked

      - name: Bump API Version
        id: bump
        run: |
          cd api/server
          OLD_VERSION=$(cargo read-manifest | jq -r .version)
          VERSION_SPEC="${{ needs.determine_version_params.outputs.version_spec }}"
          
          if [[ "$VERSION_SPEC" == "major" || "$VERSION_SPEC" == "minor" || "$VERSION_SPEC" == "patch" ]]; then
            cargo set-version --bump "$VERSION_SPEC"
          else
            CLEANED_VERSION_SPEC=$(echo "$VERSION_SPEC" | sed 's/^v//')
            cargo set-version "$CLEANED_VERSION_SPEC"
          fi
          
          NEW_VERSION=$(cargo read-manifest | jq -r .version)
          echo "API: $OLD_VERSION -> $NEW_VERSION"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "old_version=$OLD_VERSION" >> $GITHUB_OUTPUT
          
          if [[ "$OLD_VERSION" != "$NEW_VERSION" ]]; then
            git add Cargo.toml
            git commit -m "chore(versions): bump api to v$NEW_VERSION [skip ci]"
            git push origin HEAD:${{ needs.determine_version_params.outputs.target_branch }}
          fi

  # Job to bump Web version
  bump_web_version:
    name: Bump Web Version
    needs: determine_version_params
    if: |
      (needs.determine_version_params.outputs.component == 'all' || 
       needs.determine_version_params.outputs.component == 'web') &&
      needs.determine_version_params.outputs.component != 'none'
    runs-on: blacksmith
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
      old_version: ${{ steps.bump.outputs.old_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine_version_params.outputs.target_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Bump Web Version
        id: bump
        run: |
          cd web
          OLD_VERSION=$(jq -r .version package.json)
          VERSION_SPEC="${{ needs.determine_version_params.outputs.version_spec }}"
          
          npm version "$VERSION_SPEC" --no-git-tag-version --allow-same-version
          NEW_VERSION=$(jq -r .version package.json)
          echo "Web: $OLD_VERSION -> $NEW_VERSION"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "old_version=$OLD_VERSION" >> $GITHUB_OUTPUT
          
          if [[ "$OLD_VERSION" != "$NEW_VERSION" ]]; then
            git add package.json package-lock.json
            git commit -m "chore(versions): bump web to v$NEW_VERSION [skip ci]"
            git push origin HEAD:${{ needs.determine_version_params.outputs.target_branch }}
          fi

  # Job to bump CLI version
  bump_cli_version:
    name: Bump CLI Version
    needs: determine_version_params
    if: |
      (needs.determine_version_params.outputs.component == 'all' || 
       needs.determine_version_params.outputs.component == 'cli') &&
      needs.determine_version_params.outputs.component != 'none'
    runs-on: blacksmith
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
      old_version: ${{ steps.bump.outputs.old_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine_version_params.outputs.target_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Install cargo-edit
        run: cargo install cargo-edit --locked

      - name: Bump CLI Version
        id: bump
        run: |
          cd cli/cli
          OLD_VERSION=$(cargo read-manifest | jq -r .version)
          VERSION_SPEC="${{ needs.determine_version_params.outputs.version_spec }}"
          
          if [[ "$VERSION_SPEC" == "major" || "$VERSION_SPEC" == "minor" || "$VERSION_SPEC" == "patch" ]]; then
            cargo set-version --bump "$VERSION_SPEC"
          else
            CLEANED_VERSION_SPEC=$(echo "$VERSION_SPEC" | sed 's/^v//')
            cargo set-version "$CLEANED_VERSION_SPEC"
          fi
          
          NEW_VERSION=$(cargo read-manifest | jq -r .version)
          echo "CLI: $OLD_VERSION -> $NEW_VERSION"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "old_version=$OLD_VERSION" >> $GITHUB_OUTPUT
          
          if [[ "$OLD_VERSION" != "$NEW_VERSION" ]]; then
            git add Cargo.toml
            git commit -m "chore(versions): bump cli to v$NEW_VERSION [skip ci]"
            git push origin HEAD:${{ needs.determine_version_params.outputs.target_branch }}
          fi

  # Job to create tag information file
  create_tag_info:
    name: Create Tag Information
    needs: [bump_api_version, bump_web_version, bump_cli_version]
    if: |
      always() && 
      (needs.bump_api_version.result == 'success' || needs.bump_web_version.result == 'success' || needs.bump_cli_version.result == 'success')
    runs-on: blacksmith
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine_version_params.outputs.target_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Tag Info File
        run: |
          echo "Creating tag_info.json file..."
          TAG_INFO_FILE="tag_info.json"
          echo "{" > $TAG_INFO_FILE
          FIRST_ENTRY=true

          if [[ "${{ needs.bump_api_version.outputs.new_version }}" != "" ]]; then
            if [ "$FIRST_ENTRY" = false ]; then echo "," >> $TAG_INFO_FILE; fi
            echo "  \"api_tag\": \"api/v${{ needs.bump_api_version.outputs.new_version }}\", \"api_version\": \"${{ needs.bump_api_version.outputs.new_version }}\"" >> $TAG_INFO_FILE
            FIRST_ENTRY=false
          fi

          if [[ "${{ needs.bump_web_version.outputs.new_version }}" != "" ]]; then
            if [ "$FIRST_ENTRY" = false ]; then echo "," >> $TAG_INFO_FILE; fi
            echo "  \"web_tag\": \"web/v${{ needs.bump_web_version.outputs.new_version }}\", \"web_version\": \"${{ needs.bump_web_version.outputs.new_version }}\"" >> $TAG_INFO_FILE
            FIRST_ENTRY=false
          fi

          if [[ "${{ needs.bump_cli_version.outputs.new_version }}" != "" ]]; then
            if [ "$FIRST_ENTRY" = false ]; then echo "," >> $TAG_INFO_FILE; fi
            echo "  \"cli_tag\": \"cli/v${{ needs.bump_cli_version.outputs.new_version }}\", \"cli_version\": \"${{ needs.bump_cli_version.outputs.new_version }}\"" >> $TAG_INFO_FILE
            FIRST_ENTRY=false
          fi

          echo "}" >> $TAG_INFO_FILE
          
          git add $TAG_INFO_FILE
          git commit -m "chore: update tag_info.json with potential release versions [skip ci]"
          git push origin HEAD:${{ needs.determine_version_params.outputs.target_branch }}

      - name: Upload Tag Information Artifact
        uses: actions/upload-artifact@v4
        with:
          name: version-tag-info
          path: tag_info.json
          retention-days: 7 