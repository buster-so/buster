name: Build and Push Docker Images

on:
  push:
    branches: [main, staging]
    paths:
      - 'apps/**'
      - 'packages/**'
      - 'pnpm-lock.yaml'
      - '.github/workflows/docker-build-push.yml'
      - '.github/workflows/deploy.yml'
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [staging]
  workflow_dispatch:
    inputs:
      force_build:
        description: 'Force a build even without changes'
        required: false
        default: 'false'

# Cancel in-progress runs when new commits are pushed to the same PR
# Queue runs for main/staging branches
concurrency:
  group: docker-build-${{ github.event_name == 'pull_request' && format('pr-{0}', github.event.pull_request.number) || github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  REGISTRY: ghcr.io

jobs:
  # Build API (Rust)
  build-api:
    if: github.event_name != 'pull_request' || github.event.action != 'closed'
    runs-on: blacksmith-8vcpu-ubuntu-2404
    permissions:
      contents: read
      packages: write
    outputs:
      sha_short: ${{ steps.meta.outputs.sha_short }}
      success: ${{ steps.build-status.outputs.success }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Docker Builder
        uses: useblacksmith/setup-docker-builder@v1
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata and determine tags
        id: meta
        run: |
          SHA_SHORT=$(git rev-parse --short=7 HEAD)
          echo "sha_short=${SHA_SHORT}" >> $GITHUB_OUTPUT
          
          # Read version from Cargo.toml if on main
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            VERSION=$(grep '^version' apps/api/Cargo.toml | head -n 1 | sed 's/version = "\(.*\)"/\1/' || echo "")
            if [ -n "$VERSION" ]; then
              echo "version=${VERSION}" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Determine tags based on context
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "tags=${{ env.REGISTRY }}/buster-so/buster-api:preview-${SHA_SHORT}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "main" ]]; then
            TAGS="${{ env.REGISTRY }}/buster-so/buster-api:${SHA_SHORT},${{ env.REGISTRY }}/buster-so/buster-api:latest"
            if [ -n "$VERSION" ]; then
              TAGS="${TAGS},${{ env.REGISTRY }}/buster-so/buster-api:${VERSION}"
            fi
            echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "staging" ]]; then
            echo "tags=${{ env.REGISTRY }}/buster-so/buster-api:staging-${SHA_SHORT},${{ env.REGISTRY }}/buster-so/buster-api:staging" >> $GITHUB_OUTPUT
          fi
          
          echo "timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
      
      - name: Build and push API Docker image
        uses: useblacksmith/build-push-action@v2
        with:
          context: ./apps/api
          file: ./apps/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.meta.outputs.timestamp }}
          build-args: |
            COMMIT_SHA=${{ steps.meta.outputs.sha_short }}
            BUILD_DATE=${{ steps.meta.outputs.timestamp }}
          platforms: linux/amd64
      
      - name: Output image details
        run: |
          echo "âœ… API Docker image built and pushed!"
          echo "ðŸ“¦ Image tags:"
          echo "${{ steps.meta.outputs.tags }}" | tr ',' '\n' | sed 's/^/   - /'
      
      - name: Set build status
        id: build-status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

  # Build Server (TypeScript/Bun)
  build-server:
    if: github.event_name != 'pull_request' || github.event.action != 'closed'
    runs-on: blacksmith-8vcpu-ubuntu-2404
    permissions:
      contents: read
      packages: write
    outputs:
      sha_short: ${{ steps.meta.outputs.sha_short }}
      success: ${{ steps.build-status.outputs.success }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node and pnpm for Turbo cache
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 10
      
      - name: Mount Turbo cache sticky disk
        uses: useblacksmith/stickydisk@v1
        with:
          key: ${{ github.repository }}-turbo-cache-${{ github.ref_name }}
          path: .turbo
      
      - name: Mount pnpm store sticky disk
        uses: useblacksmith/stickydisk@v1
        with:
          key: ${{ github.repository }}-pnpm-store-${{ github.ref_name }}
          path: ~/.pnpm-store
      
      - name: Configure pnpm store path
        run: pnpm config set store-dir ~/.pnpm-store
      
      - name: Mount Docker buildkit sticky disk
        uses: useblacksmith/stickydisk@v1
        with:
          key: ${{ github.repository }}-buildkit-cache-server-${{ github.ref_name }}
          path: /tmp/.buildkit-cache-server
      
      - name: Set up Docker Builder with cache
        uses: useblacksmith/setup-docker-builder@v1
        with:
          driver-opts: |
            image=moby/buildkit:master
            network=host
          buildkitd-flags: --allow-insecure-entitlement network.host
          cache-binary: true
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata and determine tags
        id: meta
        run: |
          SHA_SHORT=$(git rev-parse --short=7 HEAD)
          echo "sha_short=${SHA_SHORT}" >> $GITHUB_OUTPUT
          
          # Read version from package.json if on main
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            VERSION=$(jq -r '.version // empty' apps/server/package.json || echo "")
            if [ -n "$VERSION" ]; then
              echo "version=${VERSION}" >> $GITHUB_OUTPUT
            fi
          fi
          
          # Determine tags based on context
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "tags=${{ env.REGISTRY }}/buster-so/buster-server:preview-${SHA_SHORT}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "main" ]]; then
            TAGS="${{ env.REGISTRY }}/buster-so/buster-server:${SHA_SHORT},${{ env.REGISTRY }}/buster-so/buster-server:latest"
            if [ -n "$VERSION" ]; then
              TAGS="${TAGS},${{ env.REGISTRY }}/buster-so/buster-server:${VERSION}"
            fi
            echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "staging" ]]; then
            echo "tags=${{ env.REGISTRY }}/buster-so/buster-server:staging-${SHA_SHORT},${{ env.REGISTRY }}/buster-so/buster-server:staging" >> $GITHUB_OUTPUT
          fi
          
          echo "timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
      
      - name: Build and push Server Docker image
        uses: useblacksmith/build-push-action@v2
        with:
          context: .
          file: ./apps/server/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.meta.outputs.timestamp }}
          build-args: |
            COMMIT_SHA=${{ steps.meta.outputs.sha_short }}
            BUILD_DATE=${{ steps.meta.outputs.timestamp }}
          platforms: linux/amd64
          cache-from: |
            type=registry,ref=${{ env.REGISTRY }}/buster-so/buster-server:buildcache
            type=local,src=/tmp/.buildkit-cache-server
          cache-to: |
            type=registry,ref=${{ env.REGISTRY }}/buster-so/buster-server:buildcache,mode=max
            type=local,dest=/tmp/.buildkit-cache-server,mode=max
      
      - name: Output image details
        run: |
          echo "âœ… Server Docker image built and pushed!"
          echo "ðŸ“¦ Image tags:"
          echo "${{ steps.meta.outputs.tags }}" | tr ',' '\n' | sed 's/^/   - /'
      
      - name: Set build status
        id: build-status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

  # Deploy API preview
  deploy-preview-api:
    if: github.event_name == 'pull_request' && github.base_ref == 'staging' && needs.build-api.outputs.success == 'true' && needs.build-server.outputs.success == 'true'
    needs: [build-api, build-server]
    runs-on: blacksmith-8vcpu-ubuntu-2404
    environment: testing
    outputs:
      api_url: ${{ steps.deploy.outputs.api_url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup porter
      uses: porter-dev/setup-porter@v0.1.0
    
    - name: Install Supabase CLI
      run: |
        curl -L https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar xvz
        sudo mv supabase /usr/local/bin/
        supabase --version
    
    - name: Create Supabase preview branch
      id: supabase-branch
      run: |
        # Use the actual branch name from the PR
        BRANCH_NAME="${{ github.head_ref }}"
        echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        
        # Create or update the preview branch
        supabase branches create ${BRANCH_NAME} --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} || true
        
        # Get the branch database URL and settings
        BRANCH_INFO=$(supabase branches list --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json | jq -r ".[] | select(.name == \"${BRANCH_NAME}\")")
        BRANCH_ID=$(echo $BRANCH_INFO | jq -r '.id')
        
        # Get project settings to extract URLs and keys
        PROJECT_INFO=$(supabase projects api-keys --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json)
        
        # Extract the anon key and service role key
        SUPABASE_ANON_KEY=$(echo $PROJECT_INFO | jq -r '.[] | select(.name == "anon") | .api_key')
        
        # The Supabase URL is standard format
        SUPABASE_URL="https://${{ secrets.SUPABASE_PROJECT_ID }}.supabase.co"
        
        # The database URL will be in the format: postgresql://postgres.[project-ref]:[password]@[host]:6543/postgres?pgbouncer=true
        # We'll construct it based on the branch
        DB_HOST="db.${{ secrets.SUPABASE_PROJECT_ID }}-${BRANCH_ID}.supabase.co"
        DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:6543/postgres?pgbouncer=true"
        # Direct connection URL for Electric (without pgbouncer)
        DIRECT_DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:5432/postgres"
        
        echo "database_url=${DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "direct_database_url=${DIRECT_DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_url=${SUPABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_anon_key=${SUPABASE_ANON_KEY}" >> $GITHUB_OUTPUT
        echo "âœ… Created Supabase preview branch: ${BRANCH_NAME}"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
    
    - name: Deploy API preview
      timeout-minutes: 30
      run: |
        SHA_SHORT="${{ needs.build-api.outputs.sha_short }}"
        PR_NUMBER="${{ github.event.pull_request.number }}"
        
        echo "ðŸš€ Deploying API preview for PR #${PR_NUMBER} (SHA: ${SHA_SHORT})"
        
        cat > /tmp/porter-api.yaml <<EOF
        version: v2
        name: staging-legacy
        services:
        - name: api
          run: ""
          type: web
          image:
            repository: ghcr.io/buster-so/buster-api
            tag: preview-${SHA_SHORT}
          instances: 1
          cpuCores: 1
          ramMegabytes: 2048
          port: 3001
          env:
            DATABASE_URL: ${{ steps.supabase-branch.outputs.database_url }}
        envGroups:
        - staging
        EOF
        
        exec porter apply -f /tmp/porter-api.yaml --preview
        
        # Output predictable URL
        API_URL="https://staging-legacy-pr-${PR_NUMBER}.porter.run"
        echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
        echo "âœ… API preview deployment initiated with Supabase branch"
        echo "ðŸ“ API URL: ${API_URL}"
      id: deploy
      env:
        PORTER_CLUSTER: 3155
        PORTER_HOST: https://dashboard.porter.run
        PORTER_PROJECT: 9309
        PORTER_APP_NAME: staging-legacy
        PORTER_TAG: preview-${{ needs.build-api.outputs.sha_short }}
        PORTER_TOKEN: ${{ secrets.PORTER_APP_9309_3155 }}
        PORTER_PR_NUMBER: ${{ github.event.pull_request.number }}
        PORTER_REPO_NAME: ${{ github.event.repository.name }}

  # Deploy Server preview
  deploy-preview-server:
    if: github.event_name == 'pull_request' && github.base_ref == 'staging' && needs.build-api.outputs.success == 'true' && needs.build-server.outputs.success == 'true'
    needs: [build-api, build-server]
    runs-on: blacksmith-8vcpu-ubuntu-2404
    environment: testing
    outputs:
      server_url: ${{ steps.deploy.outputs.server_url }}
      database_url: ${{ steps.supabase-branch.outputs.database_url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup porter
      uses: porter-dev/setup-porter@v0.1.0
    
    - name: Install Supabase CLI
      run: |
        curl -L https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar xvz
        sudo mv supabase /usr/local/bin/
        supabase --version
    
    - name: Create Supabase preview branch
      id: supabase-branch
      run: |
        # Use the actual branch name from the PR
        BRANCH_NAME="${{ github.head_ref }}"
        echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        
        # Create or update the preview branch
        supabase branches create ${BRANCH_NAME} --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} || true
        
        # Get the branch database URL and settings
        BRANCH_INFO=$(supabase branches list --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json | jq -r ".[] | select(.name == \"${BRANCH_NAME}\")")
        BRANCH_ID=$(echo $BRANCH_INFO | jq -r '.id')
        
        # Get project settings to extract URLs and keys
        PROJECT_INFO=$(supabase projects api-keys --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json)
        
        # Extract the anon key and service role key
        SUPABASE_ANON_KEY=$(echo $PROJECT_INFO | jq -r '.[] | select(.name == "anon") | .api_key')
        
        # The Supabase URL is standard format
        SUPABASE_URL="https://${{ secrets.SUPABASE_PROJECT_ID }}.supabase.co"
        
        # The database URL will be in the format: postgresql://postgres.[project-ref]:[password]@[host]:6543/postgres?pgbouncer=true
        # We'll construct it based on the branch
        DB_HOST="db.${{ secrets.SUPABASE_PROJECT_ID }}-${BRANCH_ID}.supabase.co"
        DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:6543/postgres?pgbouncer=true"
        # Direct connection URL for Electric (without pgbouncer)
        DIRECT_DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:5432/postgres"
        
        echo "database_url=${DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "direct_database_url=${DIRECT_DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_url=${SUPABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_anon_key=${SUPABASE_ANON_KEY}" >> $GITHUB_OUTPUT
        echo "âœ… Created Supabase preview branch: ${BRANCH_NAME}"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: 10
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Deploy Trigger.dev preview
      run: |
        # Use the actual branch name from the PR
        BRANCH_NAME="${{ github.head_ref }}"
        echo "ðŸš€ Deploying Trigger.dev preview for branch: ${BRANCH_NAME}"
        
        # Deploy to Trigger.dev preview environment from the trigger app directory
        cd apps/trigger && npx trigger.dev@latest deploy --env preview --branch ${BRANCH_NAME}
        
        echo "âœ… Trigger.dev preview deployment complete"
      env:
        TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
        DATABASE_URL: ${{ steps.supabase-branch.outputs.database_url }}
    
    - name: Deploy Server preview
      timeout-minutes: 30
      run: |
        SHA_SHORT="${{ needs.build-server.outputs.sha_short }}"
        PR_NUMBER="${{ github.event.pull_request.number }}"
        
        echo "ðŸš€ Deploying Server preview for PR #${PR_NUMBER} (SHA: ${SHA_SHORT})"
        
        cat > /tmp/porter-server.yaml <<EOF
        version: v2
        name: staging-server
        services:
        - name: server
          run: ""
          type: web
          image:
            repository: ghcr.io/buster-so/buster-server
            tag: preview-${SHA_SHORT}
          instances: 1
          cpuCores: 2
          ramMegabytes: 5000
          port: 3002
          env:
            DATABASE_URL: ${{ steps.supabase-branch.outputs.database_url }}
            TRIGGER_PREVIEW_BRANCH: ${{ github.head_ref }}
            TRIGGER_SECRET_KEY: ${{ secrets.TRIGGER_SECRET_KEY }}
        envGroups:
        - staging
        EOF
        
        exec porter apply -f /tmp/porter-server.yaml --preview
        
        # Output predictable URL
        SERVER_URL="https://staging-server-pr-${PR_NUMBER}.porter.run"
        echo "server_url=${SERVER_URL}" >> $GITHUB_OUTPUT
        echo "âœ… Server preview deployment initiated with Supabase and Trigger.dev"
        echo "ðŸ“ Server URL: ${SERVER_URL}"
      id: deploy
      env:
        PORTER_CLUSTER: 3155
        PORTER_HOST: https://dashboard.porter.run
        PORTER_PROJECT: 9309
        PORTER_APP_NAME: staging-server
        PORTER_TAG: preview-${{ needs.build-server.outputs.sha_short }}
        PORTER_TOKEN: ${{ secrets.PORTER_APP_9309_3155 }}
        PORTER_PR_NUMBER: ${{ github.event.pull_request.number }}
        PORTER_REPO_NAME: ${{ github.event.repository.name }}

  # Deploy Web preview to Vercel
  deploy-preview-web:
    if: github.event_name == 'pull_request' && github.base_ref == 'staging' && needs.build-api.outputs.success == 'true' && needs.build-server.outputs.success == 'true'
    needs: [build-api, build-server, deploy-preview-api, deploy-preview-server]
    runs-on: blacksmith-8vcpu-ubuntu-2404
    environment: testing
    outputs:
      web_url: ${{ steps.vercel-deploy.outputs.deployment_url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Supabase CLI
      run: |
        curl -L https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar xvz
        sudo mv supabase /usr/local/bin/
        supabase --version
    
    - name: Get Supabase preview branch URL
      id: supabase-branch
      run: |
        # Use the actual branch name from the PR
        BRANCH_NAME="${{ github.head_ref }}"
        echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        
        # Get the existing branch database URL (created by server deployment)
        BRANCH_INFO=$(supabase branches list --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json | jq -r ".[] | select(.name == \"${BRANCH_NAME}\")")
        BRANCH_ID=$(echo $BRANCH_INFO | jq -r '.id')
        
        if [ -z "$BRANCH_ID" ] || [ "$BRANCH_ID" == "null" ]; then
          echo "âš ï¸ Supabase branch not found. Creating new branch..."
          supabase branches create ${BRANCH_NAME} --project-ref ${{ secrets.SUPABASE_PROJECT_ID }}
          BRANCH_INFO=$(supabase branches list --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json | jq -r ".[] | select(.name == \"${BRANCH_NAME}\")")
          BRANCH_ID=$(echo $BRANCH_INFO | jq -r '.id')
        fi
        
        # Get project settings to extract URLs and keys
        PROJECT_INFO=$(supabase projects api-keys --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json)
        
        # Extract the anon key
        SUPABASE_ANON_KEY=$(echo $PROJECT_INFO | jq -r '.[] | select(.name == "anon") | .api_key')
        
        # The Supabase URL is standard format
        SUPABASE_URL="https://${{ secrets.SUPABASE_PROJECT_ID }}.supabase.co"
        
        # The database URL will be in the format: postgresql://postgres.[project-ref]:[password]@[host]:6543/postgres?pgbouncer=true
        # We'll construct it based on the branch
        DB_HOST="db.${{ secrets.SUPABASE_PROJECT_ID }}-${BRANCH_ID}.supabase.co"
        DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:6543/postgres?pgbouncer=true"
        # Direct connection URL for Electric (without pgbouncer)
        DIRECT_DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:5432/postgres"
        
        echo "database_url=${DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "direct_database_url=${DIRECT_DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_url=${SUPABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_anon_key=${SUPABASE_ANON_KEY}" >> $GITHUB_OUTPUT
        echo "âœ… Using Supabase preview branch: ${BRANCH_NAME}"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: 10
    
    - name: Install Vercel CLI
      run: npm install --global vercel@latest
    
    - name: Deploy to Vercel Preview
      id: vercel-deploy
      run: |
        cd apps/web
        
        # Get the PR number for constructing predictable URLs
        PR_NUMBER="${{ github.event.pull_request.number }}"
        
        # Deploy to Vercel with environment variables set
        # Vercel will handle the build process
        DEPLOYMENT_URL=$(vercel deploy \
          --env DATABASE_URL="${{ steps.supabase-branch.outputs.database_url }}" \
          --env VITE_PUBLIC_API_URL="https://staging-legacy-pr-${PR_NUMBER}.porter.run" \
          --env VITE_PUBLIC_API2_URL="https://staging-server-pr-${PR_NUMBER}.porter.run" \
          --env VITE_PUBLIC_WEB_SOCKET_URL="wss://staging-legacy-pr-${PR_NUMBER}.porter.run" \
          --env VITE_PUBLIC_URL="https://buster-web-pr-${PR_NUMBER}.vercel.app" \
          --env VITE_PUBLIC_SUPABASE_URL="${{ steps.supabase-branch.outputs.supabase_url }}" \
          --env VITE_PUBLIC_SUPABASE_ANON_KEY="${{ steps.supabase-branch.outputs.supabase_anon_key }}" \
          --token=${{ secrets.VERCEL_TOKEN }} \
          --yes | tail -n 1)
        
        echo "deployment_url=${DEPLOYMENT_URL}" >> $GITHUB_OUTPUT
        
        # Add comment to PR with preview URL
        echo "ðŸš€ Web preview deployed to: ${DEPLOYMENT_URL}"
        echo "âœ… Vercel preview deployment complete"
      env:
        VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  # Deploy Electric server preview
  deploy-preview-electric:
    if: github.event_name == 'pull_request' && github.base_ref == 'staging' && needs.build-api.outputs.success == 'true' && needs.build-server.outputs.success == 'true'
    needs: [build-api, build-server]
    runs-on: blacksmith-8vcpu-ubuntu-2404
    environment: testing
    outputs:
      electric_url: ${{ steps.deploy.outputs.electric_url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup porter
      uses: porter-dev/setup-porter@v0.1.0
    
    - name: Install Supabase CLI
      run: |
        curl -L https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar xvz
        sudo mv supabase /usr/local/bin/
        supabase --version
    
    - name: Get Supabase preview branch URL
      id: supabase-branch
      run: |
        # Use the actual branch name from the PR
        BRANCH_NAME="${{ github.head_ref }}"
        echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        
        # Get the existing branch database URL (created by server deployment)
        BRANCH_INFO=$(supabase branches list --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json | jq -r ".[] | select(.name == \"${BRANCH_NAME}\")")
        BRANCH_ID=$(echo $BRANCH_INFO | jq -r '.id')
        
        if [ -z "$BRANCH_ID" ] || [ "$BRANCH_ID" == "null" ]; then
          echo "âŒ Supabase branch not found. Creating new branch..."
          supabase branches create ${BRANCH_NAME} --project-ref ${{ secrets.SUPABASE_PROJECT_ID }}
          BRANCH_INFO=$(supabase branches list --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} --output json | jq -r ".[] | select(.name == \"${BRANCH_NAME}\")")
          BRANCH_ID=$(echo $BRANCH_INFO | jq -r '.id')
        fi
        
        # The database URL will be in the format: postgresql://postgres.[project-ref]:[password]@[host]:6543/postgres?pgbouncer=true
        # We'll construct it based on the branch
        DB_HOST="db.${{ secrets.SUPABASE_PROJECT_ID }}-${BRANCH_ID}.supabase.co"
        DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:6543/postgres?pgbouncer=true"
        # Direct connection URL for Electric (without pgbouncer)
        DIRECT_DATABASE_URL="postgresql://postgres.${{ secrets.SUPABASE_PROJECT_ID }}:${{ secrets.SUPABASE_DB_PASSWORD }}@${DB_HOST}:5432/postgres"
        
        # Supabase API URL and anon key are project-specific, not branch-specific
        SUPABASE_URL="https://${{ secrets.SUPABASE_PROJECT_ID }}.supabase.co"
        SUPABASE_ANON_KEY="${{ secrets.SUPABASE_ANON_KEY }}"
        
        echo "database_url=${DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "direct_database_url=${DIRECT_DATABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_url=${SUPABASE_URL}" >> $GITHUB_OUTPUT
        echo "supabase_anon_key=${SUPABASE_ANON_KEY}" >> $GITHUB_OUTPUT
        echo "âœ… Using Supabase preview branch: ${BRANCH_NAME}"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
    
    - name: Deploy Electric server preview
      timeout-minutes: 30
      run: |
        SHA_SHORT="${{ needs.build-server.outputs.sha_short }}"
        PR_NUMBER="${{ github.event.pull_request.number }}"
        
        echo "ðŸš€ Deploying Electric preview for PR #${PR_NUMBER} (SHA: ${SHA_SHORT})"
        
        # Update Electric porter.yaml to use the direct preview database URL (without pgbouncer)
        cat > /tmp/porter-electric.yaml <<EOF
        $(cat ./apps/electric-server/porter.yaml)
        env:
          DATABASE_URL: ${{ steps.supabase-branch.outputs.direct_database_url }}
        EOF
        
        exec porter apply -f /tmp/porter-electric.yaml --preview
        
        # Output predictable URL
        ELECTRIC_URL="https://electric-pr-${PR_NUMBER}.porter.run"
        echo "electric_url=${ELECTRIC_URL}" >> $GITHUB_OUTPUT
        echo "âœ… Electric preview deployment initiated with Supabase branch"
        echo "ðŸ“ Electric URL: ${ELECTRIC_URL}"
      id: deploy
      env:
        PORTER_CLUSTER: 3155
        PORTER_HOST: https://dashboard.porter.run
        PORTER_PROJECT: 9309
        PORTER_APP_NAME: electric
        PORTER_TAG: ${{ needs.build-server.outputs.sha_short }}
        PORTER_TOKEN: ${{ secrets.PORTER_APP_9309_3155 }}
        PORTER_PR_NUMBER: ${{ github.event.pull_request.number }}
        PORTER_REPO_NAME: ${{ github.event.repository.name }}

  # Run E2E tests on preview environments
  run-e2e-tests:
    if: github.event_name == 'pull_request' && github.base_ref == 'staging' && github.event.action != 'closed'
    needs: [deploy-preview-api, deploy-preview-server, deploy-preview-web, deploy-preview-electric]
    runs-on: blacksmith-8vcpu-ubuntu-2404
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: 10
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Install Playwright browsers
      run: npx playwright install --with-deps chromium
    
    - name: Run E2E tests against preview environment
      run: |
        echo "ðŸ§ª Running E2E tests against preview environments"
        echo "Web URL: ${{ needs.deploy-preview-web.outputs.web_url }}"
        echo "API URL: ${{ needs.deploy-preview-api.outputs.api_url }}"
        echo "Server URL: ${{ needs.deploy-preview-server.outputs.server_url }}"
        
        # Run your E2E tests with the preview URLs
        pnpm run test:e2e || true  # Set to || true temporarily until tests are set up
      env:
        VITE_WEB_URL: ${{ needs.deploy-preview-web.outputs.web_url }}
        VITE_API_URL: ${{ needs.deploy-preview-api.outputs.api_url }}
        VITE_SERVER_URL: ${{ needs.deploy-preview-server.outputs.server_url }}
        VITE_ELECTRIC_URL: ${{ needs.deploy-preview-electric.outputs.electric_url }}
        DATABASE_URL: ${{ needs.deploy-preview-server.outputs.database_url }}
        PLAYWRIGHT_BASE_URL: ${{ needs.deploy-preview-web.outputs.web_url }}
        CI: true
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: e2e-test-results-pr-${{ github.event.pull_request.number }}
        path: |
          test-results/
          playwright-report/
        retention-days: 7

  # Summary job to report all preview deployments and tests
  deploy-preview-summary:
    if: github.event_name == 'pull_request' && github.base_ref == 'staging' && github.event.action != 'closed'
    needs: [deploy-preview-api, deploy-preview-server, deploy-preview-web, deploy-preview-electric, run-e2e-tests]
    runs-on: blacksmith-8vcpu-ubuntu-2404
    
    steps:
    - name: Output deployment summary
      run: |
        echo "## ðŸŽ‰ All Preview Deployments & Tests Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Preview URLs (Predictable):" >> $GITHUB_STEP_SUMMARY
        echo "- **Web:** ${{ needs.deploy-preview-web.outputs.web_url }}" >> $GITHUB_STEP_SUMMARY
        echo "- **API:** ${{ needs.deploy-preview-api.outputs.api_url }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Server:** ${{ needs.deploy-preview-server.outputs.server_url }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Electric:** ${{ needs.deploy-preview-electric.outputs.electric_url }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ§ª E2E Test Results:" >> $GITHUB_STEP_SUMMARY
        echo "- **Status:** ${{ needs.run-e2e-tests.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ’¡ **Note:** URLs are predictable based on PR number for easy testing" >> $GITHUB_STEP_SUMMARY

  # Deploy to staging/main environments on merge
  deploy-staging-main:
    if: github.event_name == 'push' && (github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/main') && needs.build-api.outputs.success == 'true' && needs.build-server.outputs.success == 'true'
    needs: [build-api, build-server]
    runs-on: blacksmith-8vcpu-ubuntu-2404
    environment: ${{ github.ref_name }}
    
    steps:
    - name: Setup porter
      uses: porter-dev/setup-porter@v0.1.0
    
    - name: Determine image tag
      id: tag
      run: |
        SHA_SHORT="${{ needs.build-server.outputs.sha_short }}"
        
        if [[ "${{ github.ref_name }}" == "main" ]]; then
          TAG="${SHA_SHORT}"
        else
          TAG="${{ github.ref_name }}-${SHA_SHORT}"
        fi
        
        echo "tag=${TAG}" >> $GITHUB_OUTPUT
        echo "ðŸš€ Deploying to ${{ github.ref_name }} environment"
        echo "ðŸ“¦ Using image tag: ${TAG}"
    
    - name: Update API deployment
      run: |
        porter app update-tag staging-legacy --tag "${{ steps.tag.outputs.tag }}"
      env:
        PORTER_TOKEN: ${{ secrets.PORTER_TOKEN }}
        PORTER_HOST: https://dashboard.porter.run
        PORTER_PROJECT: ${{ vars.PORTER_PROJECT }}
        PORTER_CLUSTER: ${{ vars.PORTER_CLUSTER }}
    
    - name: Update Server deployment
      run: |
        porter app update-tag staging-server --tag "${{ steps.tag.outputs.tag }}"
      env:
        PORTER_TOKEN: ${{ secrets.PORTER_TOKEN }}
        PORTER_HOST: https://dashboard.porter.run
        PORTER_PROJECT: ${{ vars.PORTER_PROJECT }}
        PORTER_CLUSTER: ${{ vars.PORTER_CLUSTER }}
    
    - name: Create deployment summary
      run: |
        echo "## ðŸŽ‰ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Image Tag:** \`${{ steps.tag.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # Cleanup preview environments when PR is closed
  cleanup-preview:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: blacksmith-8vcpu-ubuntu-2404
    environment: testing
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Supabase CLI
      run: |
        curl -L https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar xvz
        sudo mv supabase /usr/local/bin/
        supabase --version
    
    - name: Delete Supabase preview branches
      run: |
        # Use the actual branch name from the PR
        BRANCH_NAME="${{ github.head_ref }}"
        
        # Delete the branch for this PR
        BRANCH_NAMES=(
          "${BRANCH_NAME}"
        )
        
        for BRANCH_NAME in "${BRANCH_NAMES[@]}"; do
          echo "ðŸ—‘ï¸ Deleting Supabase branch: ${BRANCH_NAME}"
          supabase branches delete ${BRANCH_NAME} --project-ref ${{ secrets.SUPABASE_PROJECT_ID }} || true
        done
        
        echo "âœ… Supabase preview branches deleted"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: 10
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Archive Trigger.dev preview branch
      run: |
        # Use the actual branch name from the PR
        BRANCH_NAME="${{ github.head_ref }}"
        echo "ðŸ“¦ Archiving Trigger.dev preview branch: ${BRANCH_NAME}"
        
        # Archive the preview branch from the trigger app directory
        cd apps/trigger && npx trigger.dev@latest preview archive --branch ${BRANCH_NAME} || true
        
        echo "âœ… Trigger.dev preview branch archived"
      env:
        TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
    
    - name: Remove Vercel preview deployment
      run: |
        echo "ðŸ—‘ï¸ Removing Vercel preview deployments for PR #${{ github.event.pull_request.number }}"
        
        # Note: Vercel automatically handles preview cleanup when PRs are closed
        # But we can manually remove if needed using the API
        # vercel remove [deployment-url] --yes --token=${{ secrets.VERCEL_TOKEN }}
        
        echo "âœ… Vercel will automatically clean up preview deployments"
      env:
        VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
    
    - name: Create cleanup summary
      run: |
        echo "## ðŸ§¹ Preview Environment Cleanup Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Supabase branches:** Deleted" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger.dev branch:** Archived" >> $GITHUB_STEP_SUMMARY
        echo "- **Vercel previews:** Will be cleaned up automatically" >> $GITHUB_STEP_SUMMARY
        echo "- **Porter previews:** Will be cleaned up automatically" >> $GITHUB_STEP_SUMMARY