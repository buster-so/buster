import type { ModelMessage, StreamTextResult, ToolSet } from 'ai';
import { tool } from 'ai';
import { z } from 'zod';
import { createTaskToolExecute } from './task-tool-execute';

export const TaskToolInputSchema = z.object({
  instructions: z
    .string()
    .describe(
      'Detailed instructions for the task to execute. Be specific about what the task agent should accomplish.'
    ),
});

export const TaskToolOutputSchema = z.discriminatedUnion('status', [
  z.object({
    status: z.literal('success'),
    summary: z.string().describe('Summary of what the task accomplished'),
    messages: z.array(z.any()).describe('All messages generated by the task during execution'),
  }),
  z.object({
    status: z.literal('error'),
    error_message: z.string(),
  }),
]);

// Type for agent factory function
export type AgentFactory = (options: {
  folder_structure: string;
  userId: string;
  chatId: string;
  dataSourceId: string;
  organizationId: string;
  messageId: string;
  isSubagent?: boolean;
  onToolEvent?: (event: ToolEventType) => void;
}) => {
  stream: (options: { messages: ModelMessage[] }) => Promise<StreamTextResult<ToolSet, never>>;
};

// Type for tool events
export interface ToolEventType {
  tool: string;
  event: 'start' | 'complete';
  args: unknown;
  result?: unknown;
}

const _TaskToolContextSchema = z.object({
  messageId: z.string().describe('The message ID for database updates'),
  projectDirectory: z.string().describe('The root directory of the project'),
  onToolEvent: z.function().optional().describe('Callback for tool events'),
  createAgent: z
    .function()
    .describe('Factory function to create a new agent instance for the task'),
});

export type TaskToolInput = z.infer<typeof TaskToolInputSchema>;
export type TaskToolOutput = z.infer<typeof TaskToolOutputSchema>;

// Custom context type with proper typing
export interface TaskToolContext {
  messageId: string;
  projectDirectory: string;
  onToolEvent?: (event: ToolEventType) => void;
  createAgent: AgentFactory;
}

// Type for internal task messages
export interface TaskMessage {
  tool: string;
  event: 'start' | 'complete';
  // biome-ignore lint/suspicious/noExplicitAny: Messages from sub-tasks can have any shape
  args: any;
  // biome-ignore lint/suspicious/noExplicitAny: Results from sub-tasks can have any shape
  result?: any;
}

export function createTaskTool<TAgentContext extends TaskToolContext = TaskToolContext>(
  context: TAgentContext
) {
  const execute = createTaskToolExecute(context);

  return tool({
    description: `Delegate a specialized task to a task agent. Use this when you need to execute a complex, self-contained task that would benefit from dedicated focus. The task agent will have access to all file tools (read, write, edit, bash, grep, ls) to complete the task. Provide clear, specific instructions for what the task should accomplish.`,
    inputSchema: TaskToolInputSchema,
    outputSchema: TaskToolOutputSchema,
    execute,
  });
}
