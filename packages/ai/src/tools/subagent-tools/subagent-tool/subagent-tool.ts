import type { ModelMessage, StreamTextResult, ToolSet } from 'ai';
import { tool } from 'ai';
import { z } from 'zod';
import { createSubagentToolExecute } from './subagent-tool-execute';

export const SubagentToolInputSchema = z.object({
  instructions: z
    .string()
    .describe(
      'Detailed instructions for the subagent to execute. Be specific about what the subagent should accomplish.'
    ),
});

export const SubagentToolOutputSchema = z.discriminatedUnion('status', [
  z.object({
    status: z.literal('success'),
    summary: z.string().describe('Summary of what the subagent accomplished'),
    messages: z.array(z.any()).describe('All messages generated by the subagent during execution'),
  }),
  z.object({
    status: z.literal('error'),
    error_message: z.string(),
  }),
]);

// Type for agent factory function
export type AgentFactory = (options: {
  folder_structure: string;
  userId: string;
  chatId: string;
  dataSourceId: string;
  organizationId: string;
  messageId: string;
  isSubagent?: boolean;
  onToolEvent?: (event: ToolEventType) => void;
}) => {
  stream: (options: { messages: ModelMessage[] }) => Promise<StreamTextResult<ToolSet, never>>;
};

// Type for tool events
export interface ToolEventType {
  tool: string;
  event: 'start' | 'complete';
  args: unknown;
  result?: unknown;
}

const _SubagentToolContextSchema = z.object({
  messageId: z.string().describe('The message ID for database updates'),
  projectDirectory: z.string().describe('The root directory of the project'),
  onToolEvent: z.function().optional().describe('Callback for tool events'),
  createAgent: z
    .function()
    .describe('Factory function to create a new agent instance for the subagent'),
});

export type SubagentToolInput = z.infer<typeof SubagentToolInputSchema>;
export type SubagentToolOutput = z.infer<typeof SubagentToolOutputSchema>;

// Custom context type with proper typing
export interface SubagentToolContext {
  messageId: string;
  projectDirectory: string;
  onToolEvent?: (event: ToolEventType) => void;
  createAgent: AgentFactory;
}

// Type for internal subagent messages
export interface SubagentMessage {
  tool: string;
  event: 'start' | 'complete';
  args: any;
  result?: any;
}

export function createSubagentTool<TAgentContext extends SubagentToolContext = SubagentToolContext>(
  context: TAgentContext
) {
  const execute = createSubagentToolExecute(context);

  return tool({
    description: `Delegate a specialized task to a subagent. Use this when you need to execute a complex, self-contained task that would benefit from dedicated focus. The subagent will have access to all file tools (read, write, edit, bash, grep, ls) to complete the task. Provide clear, specific instructions for what the subagent should accomplish.`,
    inputSchema: SubagentToolInputSchema,
    outputSchema: SubagentToolOutputSchema,
    execute,
  });
}
